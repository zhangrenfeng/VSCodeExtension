"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
var GetTypeNameOptions;
(function (GetTypeNameOptions) {
    GetTypeNameOptions[GetTypeNameOptions["DontSkipAny"] = 0] = "DontSkipAny";
    GetTypeNameOptions[GetTypeNameOptions["SkipAny"] = 1] = "SkipAny";
})(GetTypeNameOptions = exports.GetTypeNameOptions || (exports.GetTypeNameOptions = {}));
var SkipTypeReason;
(function (SkipTypeReason) {
    SkipTypeReason[SkipTypeReason["SkipAny"] = 0] = "SkipAny";
    SkipTypeReason[SkipTypeReason["Any"] = 1] = "Any";
    SkipTypeReason[SkipTypeReason["AnyCallExpression"] = 2] = "AnyCallExpression";
    SkipTypeReason[SkipTypeReason["AnyPropertyAccessExpression"] = 3] = "AnyPropertyAccessExpression";
    SkipTypeReason[SkipTypeReason["AnyElementAccessExpression"] = 4] = "AnyElementAccessExpression";
    SkipTypeReason[SkipTypeReason["UnionOrIntersection"] = 5] = "UnionOrIntersection";
    SkipTypeReason[SkipTypeReason["OtherPrimitive"] = 6] = "OtherPrimitive";
    SkipTypeReason[SkipTypeReason["OtherNonPrimitive"] = 7] = "OtherNonPrimitive";
    SkipTypeReason[SkipTypeReason["Literal"] = 8] = "Literal";
    SkipTypeReason[SkipTypeReason["EmptyIdentifier"] = 9] = "EmptyIdentifier";
})(SkipTypeReason = exports.SkipTypeReason || (exports.SkipTypeReason = {}));
function getTypeNameForPythia(ts, options, checker, node, sf) {
    const type = checker.getTypeAtLocation(node);
    const typeSymbol = type.aliasSymbol || type.getSymbol();
    if (!typeSymbol) {
        if ((type.getFlags() & ts.TypeFlags.NonPrimitive) == 0) {
            if ((type.flags & ts.TypeFlags.Any) !== 0) {
                if (ts.isCallExpression(node)) {
                    const typeNameOfExpression = getTypeNameForPythia(ts, options, checker, node.expression, sf);
                    if (typeNameOfExpression.typeName) {
                        return { typeName: typeNameOfExpression.typeName + "()" };
                    }
                    else {
                        return { skipReason: SkipTypeReason.AnyCallExpression };
                    }
                }
                else if (ts.isPropertyAccessExpression(node)) {
                    const typeNameOfExpression = getTypeNameForPythia(ts, options, checker, node.expression, sf);
                    if (typeNameOfExpression.typeName) {
                        return { typeName: typeNameOfExpression.typeName + "." + node.name.text };
                    }
                    else {
                        return { skipReason: SkipTypeReason.AnyPropertyAccessExpression };
                    }
                }
                else if (ts.isElementAccessExpression(node)) {
                    const typeNameOfExpression = getTypeNameForPythia(ts, options, checker, node.expression, sf);
                    if (typeNameOfExpression.typeName) {
                        return { typeName: typeNameOfExpression.typeName + "[]" };
                    }
                    else {
                        return { skipReason: SkipTypeReason.AnyElementAccessExpression };
                    }
                }
                else if (options === GetTypeNameOptions.SkipAny) {
                    return { skipReason: SkipTypeReason.SkipAny };
                }
                else if (ts.isIdentifier(node)) {
                    const s = node.text;
                    if (s) {
                        return { typeName: s };
                    }
                    return { skipReason: SkipTypeReason.EmptyIdentifier };
                }
                else if (node.kind === ts.SyntaxKind.ThisKeyword) {
                    return { typeName: "this" };
                }
                else {
                    return { skipReason: SkipTypeReason.Any };
                }
            }
            else if ((type.flags & ts.TypeFlags.StringLike) !== 0) {
                return { typeName: "string" };
            }
            else if ((type.flags & ts.TypeFlags.Boolean) !== 0) {
                return { typeName: "boolean" };
            }
            else if ((type.flags & ts.TypeFlags.NumberLike) !== 0) {
                return { typeName: "number" };
            }
            else if ((type.flags & ts.TypeFlags.UnionOrIntersection) !== 0) {
                return { skipReason: SkipTypeReason.UnionOrIntersection };
            }
            else {
                return { skipReason: SkipTypeReason.OtherPrimitive };
            }
        }
        else {
            return { skipReason: SkipTypeReason.OtherNonPrimitive };
        }
    }
    else if ((typeSymbol.flags & (ts.SymbolFlags.TypeLiteral | ts.SymbolFlags.ObjectLiteral)) !== 0) {
        return { typeName: checker.typeToString(type) };
    }
    else {
        let fullyQualifiedName = checker.getFullyQualifiedName(typeSymbol);
        if (fullyQualifiedName && (fullyQualifiedName[0] === '"')) {
            const { partInQuotes, rest } = getParts(fullyQualifiedName);
            if (partInQuotes) {
                let modulePath = partInQuotes;
                if (path.isAbsolute(modulePath)) {
                    const fileName = path.basename(modulePath);
                    if (fileName === 'index') {
                        modulePath = path.dirname(modulePath);
                    }
                    const nodeModulesStart = modulePath.lastIndexOf('/node_modules/');
                    if (nodeModulesStart >= 0) {
                        const nodeModulesRelativePathStart = nodeModulesStart + '/node_modules/'.length;
                        modulePath = modulePath.substring(nodeModulesRelativePathStart);
                    }
                    else {
                        modulePath = path.basename(modulePath);
                    }
                    fullyQualifiedName = '"' + modulePath + '"' + (rest || "");
                }
            }
        }
        return { typeName: fullyQualifiedName };
    }
    function getParts(p) {
        const secondQuote = p.indexOf('"', 1);
        if (secondQuote >= 1) {
            return { partInQuotes: p.substring(1, secondQuote), rest: p.substring(secondQuote + 1) };
        }
        return {};
    }
}
exports.getTypeNameForPythia = getTypeNameForPythia;

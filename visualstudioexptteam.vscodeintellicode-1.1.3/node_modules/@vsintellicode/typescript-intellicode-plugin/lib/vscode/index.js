"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
const typeName_1 = require("../shared/typeName");
const crypto = __importStar(require("crypto"));
const fs = __importStar(require("fs"));
const zlib = __importStar(require("zlib"));
let modelPath;
let pythiaModel = undefined;
let modelVersion;
function init(modules) {
    const ts = modules.typescript;
    let languageServiceHost;
    function create(info) {
        const proxy = Object.create(null);
        for (let k of Object.keys(info.languageService)) {
            const x = info.languageService[k];
            if (x) {
                proxy[k] = (...args) => x.apply(info.languageService, args);
            }
        }
        function getPythiaModel() {
            if (!pythiaModel && modelPath) {
                try {
                    const filebuf = fs.readFileSync(modelPath);
                    const key = Buffer.from([214, 105, 172, 23, 156, 35, 36, 45, 137, 37, 195, 176, 189, 110, 127, 78, 69, 171, 205, 160, 3, 202, 114, 220, 252, 109, 233, 221, 252, 181, 45, 47]);
                    const iv = Buffer.from([60, 12, 128, 217, 163, 220, 176, 146, 213, 18, 190, 59, 212, 88, 192, 21]);
                    const decipher = crypto.createDecipheriv("aes256", key, iv);
                    const unobfuscated = Buffer.concat([decipher.update(filebuf), decipher.final()]);
                    const unzipped = zlib.gunzipSync(unobfuscated);
                    pythiaModel = JSON.parse(unzipped.toString('utf-8'));
                    modelVersion = "typescript_" + (pythiaModel.Version || "unknown");
                    info.languageServiceHost.log(`successfully loaded model from ${modelPath}`);
                }
                catch (e) {
                    info.languageServiceHost.log(`failed to load model from ${modelPath}, exception: ${e}`);
                }
            }
            return pythiaModel;
        }
        if (info.config.modelPath) {
            modelPath = info.config.modelPath;
        }
        languageServiceHost = info.languageServiceHost;
        languageServiceHost.log(`starting configuration: ${JSON.stringify(info.config)}`);
        proxy.getCompletionsAtPosition = (fileName, position, options) => getCompletionsAtPosition(ts, info, getPythiaModel, fileName, position, options);
        proxy.getCompletionEntryDetails = (fileName, position, name, formatOptions, source, preferences) => getCompletionEntryDetails(ts, info, getPythiaModel, fileName, position, name, formatOptions, source, preferences);
        return proxy;
    }
    function onConfigurationChanged(config) {
        if (languageServiceHost) {
            languageServiceHost.log(`received configuration command: ${JSON.stringify(config)}`);
        }
        if (config.modelPath) {
            modelPath = config.modelPath;
        }
    }
    return { create, onConfigurationChanged };
}
function getCompletionsAtPosition(ts, info, getPythiaModel, fileName, position, options) {
    const prior = info.languageService.getCompletionsAtPosition(fileName, position, options);
    if (prior) {
        const start = process.hrtime();
        const result = getRecommendedWords();
        const NS_PER_MS = 1e6;
        const NS_PER_SEC = 1e9;
        const elapsedTime = process.hrtime(start);
        const elapsedTimeMs = ((elapsedTime[0] * NS_PER_SEC) + elapsedTime[1]) / NS_PER_MS;
        let failureReason = "NotInModel";
        let recommendedEntries = [];
        if (result.recommendedWords.length > 0) {
            failureReason = "NotInIntersection";
            prior.entries = prior.entries.filter(e => (!e.replacementSpan || !e.insertText || e.insertText[0] !== '['));
            if (!prior.entries.some(e => e.sortText === '0')) {
                info.languageServiceHost.log(`no strong recommendations, adding entries`);
                prior.entries = prior.entries.filter(e => !result.recommendedWords.some(w => e.name === w));
                recommendedEntries = result.recommendedWords.map((w, index) => {
                    const e = {
                        name: w,
                        kind: ts.ScriptElementKind.memberVariableElement,
                        sortText: "0"
                    };
                    markAsRecommendation(e, index);
                    return e;
                });
            }
            else {
                result.recommendedWords.forEach((word, index) => {
                    const entryIndex = prior.entries.findIndex(e => e.name === word);
                    if (entryIndex >= 0) {
                        const entry = prior.entries[entryIndex];
                        info.languageServiceHost.log(`marking recommendation ${entry.name}`);
                        failureReason = "None";
                        markAsRecommendation(entry, index);
                        recommendedEntries.push(entry);
                        prior.entries.splice(entryIndex, 1);
                    }
                });
            }
            prior.entries = recommendedEntries.concat(prior.entries);
        }
        if (result.typeName && result.sequenceString) {
            let metadata = {
                ModelVersion: modelVersion || "typescript_unknown",
                Count: recommendedEntries.length,
                ModelType: (result.sequenceString && result.sequenceString !== "N") ? "Sequence" : "Frequency",
                FailureReason: failureReason,
                Class: failureReason !== "NotInModel" ? result.typeName : "",
                InIf: !!result.inConditional,
                ElapsedTime: elapsedTimeMs,
                Methods: recommendedEntries.map(e => e.insertText),
                PrevInvoc: result.sequenceString,
                ItemMetadata: Object.create(null)
            };
            prior.entries.forEach((entry, index) => {
                const itemMetadata = {
                    Id: "",
                    Index: index,
                    Method: (index < recommendedEntries.length) ? entry.insertText : ""
                };
                metadata.ItemMetadata[entry.name] = itemMetadata;
                info.languageServiceHost.log(`adding item metadata ${entry.name} => ${JSON.stringify(itemMetadata)} to completion result`);
            });
            info.languageServiceHost.log(`added metadata ${JSON.stringify(metadata)} to completion result`);
            prior.metadata = metadata;
        }
    }
    function markAsRecommendation(entry, index) {
        entry.insertText = entry.insertText || entry.name;
        entry.sortText = entry.sortText || entry.name;
        entry.name = "\u2605 " + entry.name;
        entry.sortText = `*${String.fromCharCode("a".charCodeAt(0) + index)} ${entry.sortText}`;
        info.languageServiceHost.log(`sort text for entry ${entry.name} is ${entry.sortText}`);
    }
    function getRecommendedWords() {
        const modelDoc = getPythiaModel();
        const model = modelDoc && modelDoc.model;
        if (!model) {
            return { recommendedWords: [] };
        }
        let foundNode;
        const program = info.languageService.getProgram();
        let checker;
        if (program) {
            info.languageServiceHost.log && info.languageServiceHost.log("program found");
            checker = program.getTypeChecker();
            const sf = program.getSourceFile(fileName);
            if (sf) {
                info.languageServiceHost.log && info.languageServiceHost.log("source file found");
                ts.forEachChild(sf, findTypeNameInNode.bind(undefined, checker, sf, false));
                if (foundNode) {
                    let sequenceString = undefined;
                    let recommendedWords = [];
                    info.languageServiceHost.log && info.languageServiceHost.log(`determined type: ${foundNode.typeName}`);
                    const priorInvocationSequencesToSuggestions = model[foundNode.typeName];
                    if (priorInvocationSequencesToSuggestions) {
                        info.languageServiceHost.log('found some suggestion stuff');
                        const sequences = GetPriorAccessSequences(foundNode.typeName);
                        info.languageServiceHost.log(`sequences: ${sequences.join(",")}`);
                        for (const seq of sequences) {
                            const suggestionPair = priorInvocationSequencesToSuggestions[seq];
                            const suggestions = suggestionPair && (foundNode.isInConditional ? suggestionPair[1] : suggestionPair[0]);
                            if (suggestions) {
                                sequenceString = seq;
                                info.languageServiceHost.log(`found suggestions for sequence ${seq} : ${suggestions.join(',')}`);
                                recommendedWords.push(...(suggestions.slice(0, 5)));
                                break;
                            }
                        }
                    }
                    return { typeName: foundNode.typeName, inConditional: foundNode.isInConditional, sequenceString, recommendedWords };
                }
            }
        }
        return { recommendedWords: [] };
        function findTypeNameInNode(checker, sf, isInConditional, current) {
            info.languageServiceHost.log && info.languageServiceHost.log(`looking at node ${current.kind} ${current.getStart()} ${current.getEnd()} ${position}: ${current.getText(sf)}`);
            if (ts.isPropertyAccessExpression(current) && position > current.getStart() && position <= current.getEnd()) {
                setTypeNameFromPropertyAccessExpression(checker, sf, isInConditional, current);
            }
            if (ts.isIfStatement(current)) {
                forEachConditionalNode(current.expression, current.thenStatement, current.elseStatement);
            }
            else if (ts.isConditionalExpression(current)) {
                forEachConditionalNode(current.condition, current.whenTrue, current.whenFalse);
            }
            else if (ts.isDoStatement(current) || ts.isWhileStatement(current)) {
                forEachConditionalNode(current.expression, current.statement);
            }
            else if (ts.isForStatement(current)) {
                forEachConditionalNode(current.condition, current.initializer, current.incrementor, current.statement);
            }
            else {
                current.forEachChild(findTypeNameInNode.bind(undefined, checker, sf, isInConditional));
            }
            function forEachConditionalNode(conditionalNode, ...rest) {
                conditionalNode && findTypeNameInNode(checker, sf, true, conditionalNode);
                for (const n of rest) {
                    n && findTypeNameInNode(checker, sf, isInConditional, n);
                }
            }
            function setTypeNameFromPropertyAccessExpression(checker, sf, isInConditional, node) {
                info.languageServiceHost.log("found it!");
                const typeName = typeName_1.getTypeNameForPythia(ts, typeName_1.GetTypeNameOptions.SkipAny, checker, node.expression, sf).typeName;
                if (typeName) {
                    foundNode = { typeName, node, isInConditional, sf };
                    info.languageServiceHost.log(`found type name too! ${foundNode.typeName} ${isInConditional ? "in conditional" : ""}`);
                }
            }
        }
        function GetPriorAccessSequences(typeName) {
            const accesses = [];
            GatherAccesses(typeName, foundNode.sf, foundNode.node, accesses);
            accesses.reverse();
            info.languageServiceHost.log(`prior accesses: ${accesses.join(',')}`);
            const seqs = [];
            seqs.push("N");
            if (accesses.length > 0) {
                seqs.push("N~" + accesses[0]);
            }
            if (accesses.length > 1) {
                seqs.push(accesses[0] + "~" + accesses[1]);
            }
            seqs.reverse();
            info.languageServiceHost.log(`sequences: ${seqs.join(',')}`);
            return seqs;
        }
        function GatherAccesses(typeName, current, until, results) {
            if (current.getStart() > until.getStart()) {
                return true;
            }
            current.forEachChild(child => GatherAccesses(typeName, child, until, results));
            if (ts.isPropertyAccessExpression(current) && current.expression != until) {
                const type = typeName_1.getTypeNameForPythia(ts, typeName_1.GetTypeNameOptions.SkipAny, checker, current.expression, foundNode.sf).typeName;
                if (type === typeName && current.name.text) {
                    info.languageServiceHost.log(`pushing prior access: ${current.name.text}`);
                    results.push(current.name.text);
                }
            }
        }
    }
    return prior;
}
function getCompletionEntryDetails(ts, info, getPythiaModel, fileName, position, name, formatOptions, source, preferences) {
    const isRecommendation = name.startsWith('\u2605 ');
    const strippedName = isRecommendation ? name.slice('\u2605 '.length) : name;
    if (isRecommendation) {
        info.languageServiceHost.log(`stripped name for recommendation: ${strippedName}`);
    }
    const details = info.languageService.getCompletionEntryDetails(fileName, position, strippedName, formatOptions, source, preferences);
    if (details && isRecommendation) {
        details.name = "\u2605 " + details.name;
        info.languageServiceHost.log(`starred name for recommendation: ${details.name}`);
    }
    return details;
}
module.exports = init;

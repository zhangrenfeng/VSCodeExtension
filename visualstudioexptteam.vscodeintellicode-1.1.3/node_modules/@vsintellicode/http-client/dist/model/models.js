"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./modelBlobAzureBlobStorageResponse"));
__export(require("./modelBlobResponse"));
__export(require("./modelCodebaseCreateRequest"));
__export(require("./modelCodebaseResponse"));
__export(require("./modelCreateRequest"));
__export(require("./modelInputCreateRequest"));
__export(require("./modelInputDetailsResponse"));
__export(require("./modelInputResponse"));
__export(require("./modelOutputDetailsResponse"));
__export(require("./modelOutputResponse"));
__export(require("./modelOutputTrainingDetails"));
__export(require("./modelOutputTrainingResponse"));
__export(require("./modelOutputTrainingSummary"));
__export(require("./modelResponse"));
__export(require("./redeemLinkRequest"));
__export(require("./shareLinkRequest"));
__export(require("./shareLinkResponse"));
__export(require("./user"));
__export(require("./userModel"));
__export(require("./versionExtendedDetailsResponse"));
const modelBlobAzureBlobStorageResponse_1 = require("./modelBlobAzureBlobStorageResponse");
const modelBlobResponse_1 = require("./modelBlobResponse");
const modelCodebaseCreateRequest_1 = require("./modelCodebaseCreateRequest");
const modelCodebaseResponse_1 = require("./modelCodebaseResponse");
const modelCreateRequest_1 = require("./modelCreateRequest");
const modelInputCreateRequest_1 = require("./modelInputCreateRequest");
const modelInputDetailsResponse_1 = require("./modelInputDetailsResponse");
const modelInputResponse_1 = require("./modelInputResponse");
const modelOutputDetailsResponse_1 = require("./modelOutputDetailsResponse");
const modelOutputResponse_1 = require("./modelOutputResponse");
const modelOutputTrainingDetails_1 = require("./modelOutputTrainingDetails");
const modelOutputTrainingResponse_1 = require("./modelOutputTrainingResponse");
const modelOutputTrainingSummary_1 = require("./modelOutputTrainingSummary");
const modelResponse_1 = require("./modelResponse");
const redeemLinkRequest_1 = require("./redeemLinkRequest");
const shareLinkRequest_1 = require("./shareLinkRequest");
const shareLinkResponse_1 = require("./shareLinkResponse");
const user_1 = require("./user");
const userModel_1 = require("./userModel");
const versionExtendedDetailsResponse_1 = require("./versionExtendedDetailsResponse");
let primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];
let enumsMap = {
    "ShareLinkRequest.PermissionAssignedEnum": shareLinkRequest_1.ShareLinkRequest.PermissionAssignedEnum,
};
let typeMap = {
    "ModelBlobAzureBlobStorageResponse": modelBlobAzureBlobStorageResponse_1.ModelBlobAzureBlobStorageResponse,
    "ModelBlobResponse": modelBlobResponse_1.ModelBlobResponse,
    "ModelCodebaseCreateRequest": modelCodebaseCreateRequest_1.ModelCodebaseCreateRequest,
    "ModelCodebaseResponse": modelCodebaseResponse_1.ModelCodebaseResponse,
    "ModelCreateRequest": modelCreateRequest_1.ModelCreateRequest,
    "ModelInputCreateRequest": modelInputCreateRequest_1.ModelInputCreateRequest,
    "ModelInputDetailsResponse": modelInputDetailsResponse_1.ModelInputDetailsResponse,
    "ModelInputResponse": modelInputResponse_1.ModelInputResponse,
    "ModelOutputDetailsResponse": modelOutputDetailsResponse_1.ModelOutputDetailsResponse,
    "ModelOutputResponse": modelOutputResponse_1.ModelOutputResponse,
    "ModelOutputTrainingDetails": modelOutputTrainingDetails_1.ModelOutputTrainingDetails,
    "ModelOutputTrainingResponse": modelOutputTrainingResponse_1.ModelOutputTrainingResponse,
    "ModelOutputTrainingSummary": modelOutputTrainingSummary_1.ModelOutputTrainingSummary,
    "ModelResponse": modelResponse_1.ModelResponse,
    "RedeemLinkRequest": redeemLinkRequest_1.RedeemLinkRequest,
    "ShareLinkRequest": shareLinkRequest_1.ShareLinkRequest,
    "ShareLinkResponse": shareLinkResponse_1.ShareLinkResponse,
    "User": user_1.User,
    "UserModel": userModel_1.UserModel,
    "VersionExtendedDetailsResponse": versionExtendedDetailsResponse_1.VersionExtendedDetailsResponse,
};
class ObjectSerializer {
    static findCorrectType(data, expectedType) {
        if (data == undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }
            if (!typeMap[expectedType]) {
                return expectedType;
            }
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType;
            }
            else {
                if (data[discriminatorProperty]) {
                    var discriminatorType = data[discriminatorProperty];
                    if (typeMap[discriminatorType]) {
                        return discriminatorType;
                    }
                    else {
                        return expectedType;
                    }
                }
                else {
                    return expectedType;
                }
            }
        }
    }
    static serialize(data, type) {
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) {
            let subType = type.replace("Array<", "");
            subType = subType.substring(0, subType.length - 1);
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return data.toISOString();
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) {
                return data;
            }
            type = this.findCorrectType(data, type);
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }
    static deserialize(data, type) {
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) {
            let subType = type.replace("Array<", "");
            subType = subType.substring(0, subType.length - 1);
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) {
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}
exports.ObjectSerializer = ObjectSerializer;
class HttpBasicAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    }
}
exports.HttpBasicAuth = HttpBasicAuth;
class ApiKeyAuth {
    constructor(location, paramName) {
        this.location = location;
        this.paramName = paramName;
        this.apiKey = '';
    }
    applyToRequest(requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}
exports.ApiKeyAuth = ApiKeyAuth;
class OAuth {
    constructor() {
        this.accessToken = '';
    }
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}
exports.OAuth = OAuth;
class VoidAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(_) {
    }
}
exports.VoidAuth = VoidAuth;
//# sourceMappingURL=models.js.map